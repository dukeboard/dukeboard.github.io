Make your own adaptation
---------------

### Objectives

A reactive system is caracterized by self dynamic adaptations triggered by internal or external events. In other words, it means that the adaptation strategy must be embedded into one (or more) of your components deployed in the system.    
The overall goal of this practice is to create an elastic manager for Web servers. Along this practice, you will learn to write your own elastic system by mean of simple model editions. Skills on Kevoree Script (a.k.a. KevScript) are required and this [documentation](http://kevoree.org/doc) should help you.    
In addition you should have a working compilation toolchain as described in the *level1*.

> [KevScript Documentation >](http://kevoree.org/doc)    
>
> [Practice Level 1 >](http://kevoree.org/practices/level1/)

### Setting up your environment

* Kevoree Runtime (of your choice)
* Working toolchain (Maven and IDE)
* Clone of the Kevoree-Samples repository (github / Kevoree organization)    

Step 1: Breakdown alone component
---------------
This step shows you how to write a component able to trigger an adaptation of the system by himself. For this purpose, the idea is to create a BreakdownAlone component that suppresses himself if no message is received within a give delay.    
In order to realize this step, setup your environment as in *Practice 1*: a runtime, an editor and you prefered IDE. In addition, you also need the code of the **Breakdown** that you can  find in the Kevoree-samples Github repository.> [Kevoree Samples >](https://github.com/kevoree/kevoree-samples)### Understanding the assemblyFirst of all open the Breakdown sample project in your IDE.   
To check everything is fine, we first compile the project, and lauch it using the Kevoree Runner embedded in the Kevoree Plugin. This runner reads the bootstrap configuration from a file that must be located at `src/main/kevs/main.kevs`. 

>Open a terminal
***************
```
cd Breakdown
mvn clean install
mvn kev:run
```If everything is working well, you should see :    
`00:01 INFO: A friend! delay my suppression`   
This message is displayed, because the Breakdown component has a Ticker friend component to keep it alive. Also, the squeletton of the project is initialized, but no action is taken in case the friend disapears.   

To check this configuration, we open the model of the current running system in an editor. 
See the configuration generated by the `main.kevs` bootstrap file.

> In a Kevoree Editor go to : *File > Load From Node*    
> And leave the prompt as is (default:`localhost:9000`).

Give a look at the `period` property of the *Ticker* component. The Ticker ticks every `1s` (1000 ms). This period has been set to this value in the `main.kevs` file.   
Also, you can see that the *Breakdown* component waits `2s` before feeling alone (i.e.: period in which no message is received).   
In the editor, set the `period` property of the *Ticker* component to 3s (3000ms) and push the model on the node to dynamically update the system manualy.

> See the ticker ticks every 1 second    
> See the Breakdown occurs after 2s of silence    
> Set the `time` property to 3s and push to the runtime

Now you should observe :    
`Feeling alone, should suppress myself... I'm breakdown`   
That's great actually. Now, the Breakdown detects its lonelyness, but take no action.    
Let's add this action.

### Make the component reactive

*Open* the project in your IDE    *Open* **BreakdownAlone** Java class    *Put a code* in the action to self-uninstall the component, it should like the code on the right.     
You can use the *context* to get the instance name of the component and the name of the node on which the component is deployed.    
The *modelService* gives you access to the current model of the runing system.   
The *kevScriptService* engine helps to modify a model.    
<span class="warning-bloc"><span class="fa fa-exclamation-triangle fa-lg orange"></span> The models provided by the `getCurrentModel` method are always **ReadOnly**. To be able to cahneg these models, you hae to explicitly ask for a modifiable clone as shown on the right.</span>

```java
	@Override
    public void run() {
        try {
            Log.info("i'm alone... kill myself...");
            ModelCloner cloner = new DefaultModelCloner();
            ContainerRoot clonedModel = cloner.clone(modelService.getCurrentModel().getModel());
            kevScriptService.execute("remove " + context.getNodeName() + "." + context.getInstanceName(), clonedModel);
            modelService.update(clonedModel, null);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
```

To evaluate your code, we recomand you use the Kevoree Runner facility.   
Shutdown any running *Kevoree Runtime*, and launch another one.    
A new runtime will launch using the newly compiled sources.   
<span class="info-bloc"><span class="fa fa-lightbulb-o fa-lg blue"></span> **Remember** You have to manualy update the *period* property of the `ticker` to make the *breakdown* component feel alone.</span>    
At the end of this step, you should have a component, which uninstall himself after printing the message. Verify that everything has worked by refresh the model in the editor after the supression of the breakdown component.

> To test your code:
***************
```
mvn clean install
mvn kev:run
```

Step 2 WebServer Scaler
-----------------------

#### Understand the mapping WebServer <=> Component

For sake of simplicity, this practice uses a simple mapping:     
*a component instance == a web server instance*.    
This means, each web server (i.e.: component instance) uses its own http port.    
A webserver component can serve static content, or dynamic content using data received on `inputPort`.

### Play with the toys

As a first step you can play with the Web toy library included in kevoree.

* Start a runtime and an editor (load from node)
* Load web library (for instance type `include mvn:org.kevoree.library.java:org.kevoree.library.java.web:3.0.2` in the KevScript panel of editor)
* Drag and drop a NanoBlogServer component
* Configure the http_port property for `8080`
* Push your model to a runtime
* Open a browser to `http://localhost:8080`
* You should see a `hello world` page.

As a second step you can try the dynamic content update

* Drag an drop an instance of BufferPage
* Configure its http_port property for `8081`
* Load toys library (for instance type `include mvn:org.kevoree.library.java:org.kevoree.library.java.toys:3.0.2` in the KevScript panel of editor)
* Load channels library (for instance type `include mvn:org.kevoree.library.java:org.kevoree.library.java.channels:3.0.2` in the KevScript panel of editor)
* Create a `SyncBroadcast` channel
* Create a ticker component (set property random to `true` by clicking on the component in editor)
* Bind the ticker port and input port of both new component to channel, your model should look like the figure 1.

> [Figure 1: Kevoree Web servers first toys](id:fig-webtoys)
> <img src="figures/webtoys.png" width="100%"/>

* Push your model
* Open a browser an naviguate `http://localhost:8081` , you normally observe a web page displaying the content of the data pushed by the ticker. This illustrates how we use Kevoree to display data from sensors for instance.

### Web elastic manager

In order to reply to an increasing load, web instratructures commonly use load balancers as front end and several web servers in back-ends. Due to the variation of the load, the number of backend required at a time to ensure a satisfactory quality of service vary.    
In this last step, we build a component which aims at autonomously scale the back-end servers (add and remove back-ends) according to the load.    
<span class="warning-bloc"><span class="fa fa-exclamation-triangle fa-lg orange"></span> The load balancer component works on Unix and OSX operating systems only.   
For Windows users, please comment the corresponding line in    
`src/main/kevs/main.kevs` : `add node0.lb : HAProxy`
You will not have the load balancer page, but still you can execute the scaler component and observe result in the console</span>

Hands on !

* Open the **Scaler** sample project in your IDE.
* You'll find a `src/main/kevs/main.kevs` which corresponds to the initial model
* The `Scaler.java` has to be completed. Localize the two `TODO` and replace by a call of the kevScript engine with a `add hostName.replaceByComponentName : NanoBlogServer` and `remove hostName.replaceByComponentName`.
* Compile the code with `mvn clean install`
* Run the sample (`mvn kev:run`)
* Open a browser to `http://localhost:8070` (login/mdp : kev/kev). Now you can access to the load balancer web admin page. Notice the list of backends corresponds exactly to the number of BlogServer components deployed.
* Open a browser an naviguate `http://localhost:8080` , you normally observe that the load balancer dispatches you to one or another BlogServer.
* Open the model from the node `File / Open from node`
* Modify the parameter of the scaler
* Refresh the page of the Load balancer
